#! /bin/bash
cat << EOF
/* generated with gen_ldms_dcgm_list_fields */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dcgm_agent.h>
struct fielddef { const char *macro; int field_id; char *tag;};
#define FIELDDEF(m) { #m, m, NULL },
struct fielddef all_fields[] = {
EOF
grep DCGM_FI_ /usr/include/dcgm_fields.h |grep '^#define' |grep ' [0-9]'|grep -v + | sed -e 's/#define //' -e 's/ .*//g' -e 's/^/FIELDDEF(/' -e 's/$/)/'
cat << EOF
	{ NULL, 0, NULL }
};


#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*a))
#define _GNU_SOURCE


static int dcgm_init()
{
        dcgmReturn_t rc;

        rc = dcgmInit();
        if (rc != DCGM_ST_OK) {
                return -1;
        }

        return 0;
}

static void dcgm_fini()
{
        dcgmShutdown();
}

const char *typeString(int ft)
{
	switch (ft) {
	case DCGM_FT_DOUBLE:
		return "double";
	case DCGM_FT_INT64:
		return "int64_t";
	case DCGM_FT_STRING:
		return "string";
	case DCGM_FT_TIMESTAMP:
		return "timestamp";
	default:
		return "unmapped_type";
	}
}

static void dump_dcgm_tags()
{
        int i;
	printf("field_id\ttag\tmacro\ttype\tunits\n");
        for (i = 0; i < ARRAY_SIZE(all_fields) &&
		all_fields[i].macro != NULL; i++) {

                dcgm_field_meta_p field_meta;
                field_meta = DcgmFieldGetById(all_fields[i].field_id);
		if (field_meta) {
			switch (field_meta->fieldType) {
			case DCGM_FT_DOUBLE:
			case DCGM_FT_INT64:
			case DCGM_FT_STRING:
			case DCGM_FT_TIMESTAMP:
				all_fields[i].tag = strdup(field_meta->tag);
				printf("%d\t%s\t%s\t%s\t\"%s\"\n",
					all_fields[i].field_id, field_meta->tag,
					all_fields[i].macro,
					typeString(field_meta->fieldType),
					field_meta->valueFormat->unit);
				break;
			default:
				break;
			}
		}
        }
}

int main()
{
	dcgm_init();
	dump_dcgm_tags();
	dcgm_fini();
}
EOF
